# 前言

Homework4,涉及到二阶段锁，然后大概看了下后面的内容感觉不是特别多了，想要能不能争取这周把后面两个lab都一把梭掉。加速加速！

# 正文

## Question 1: Serializability and 2PL

### (a) Yes/No questions:

1. [2 points] In Strict 2PL, a transaction does not release any locks until it commits. 

   错，可能会因为abort放弃而释放锁

2. [2 points] A schedule generated by Strict 2PL will never cause a deadlock.

   错，肯能会有死锁

3. [2 points] A schedule generated by 2PL is always view serializable.

   错，可能有Conflict Serializability

4. [2 points] A conflict serializable schedule will never contain a cycle in its prece- dence graph.

   对

5. [2 points] Every view serializable schedule is conflict serializable. 

   错，每一个conflict serializable都是serializable schedule

### (b) Serializability:
Consider the schedule given below in Table 1. R(·) and W(·) stand for ‘Read’ and ‘Write’, respectively.

![](http://image.bdwms.com/FgJRljh5ZLCWalCNTwpyescL6xSU)

1. [1 point] Is this schedule serial?

   错，顺序执行要求一个事务txn做完才执行下一个，不允许并行

2. [3 points] Give the dependency graph of this schedule. List each edge in the dependency graph like this: ‘Tx → Ty because of Z’. This notation signifies that Tx precedes Ty because Z was last read/written by Tx before it was read/written by Ty. Order the edges in ascending order with respect to x.
   - T1 →T3 because of H,B 
   - T2 →T1 because of A
   - T2 →T3 because of D,E

3. Is this schedule conflict serializable?

   是的，因为没有环存在

4. If you answer “yes” to (3), provide the equivalent serial schedule. If you answer “no”, briefly explain why.

   T2,T1,T3

5. Is this schedule possible under 2PL?

   是的

## Question 2: Deadlock Detection and Prevention

### (a) Deadlock Detection

Consider the following lock requests in Table 2. And note that

- S(·) and X(·) stand for ‘shared lock’ and ‘exclusive lock’, respectively.
- T1, T2, and T3 represent three transactions.
- LM stands for ‘lock manager’.
- Transactions will never release a granted lock.

![](http://image.bdwms.com/Fqcy-CWtMsK1FVAPthz8ISkIk1t5)

1. [3 points] For the lock requests in Table 2, determine which lock will be granted or blocked by the lock manager. Please write ‘g’ in the LM row to indicate the lock is granted and ‘b’ to indicate the lock is blocked. For example, in the table, the first lock (S(D) at time t1) is marked as granted.

   - X(C) at t2: g 
   - X(A) at t3: g  
   - S(B) at t4: g 
   - S(A) at t5: b  
   - X(B) at t6: b 
   - S(C) at t7: b

   类似读写锁，这个共享互斥锁

2. Give the wait-for graph for the lock requests in Table 2. List each edge in the graph like this: Tx → Ty because of Z (i.e., Tx is waiting for Ty to release its lock on resource Z). Order the edges in ascending order with respect to x.

   - T1 →T3 because of C 
   - T2 →T1 because of A 
   - T3 →T1 because of B
   - T3 →T2 because of B

   就跟着横轴走看时间就行了

3. Determine whether there exists a deadlock in the lock requests in Table 2, and briefly explain why.

    Deadlock exists because there is a cycle (T1 → T3 → T1) in the depen- dency graph.
    OR: Deadlock exists because there is a cycle (T1 → T3 → T2 → T1) in the depen- dency graph.

## (b) Deadlock Prevention

Consider the following lock requests in Table 3. Like before,

- S(·) and X(·) stand for ‘shared lock’ and ‘exclusive lock’, respectively.
- T1, T2, T3, T4, and T5 represent five transactions.
- LM represents a ‘lock manager’.
- Transactions will never release a granted lock.

![](http://image.bdwms.com/FmhTYarai9SuYfsDDR1u0RIJ695h)

1. [3 points] For the lock requests in Table 3, determine which lock request will be
    granted, blocked or aborted by the lock manager (LM ), if it has no deadlock prevention policy. Please write ‘g’ for grant, ‘*b*’ for block, ‘a’ for abort, and ’−’if the transaction has already died. Again, example is given in the first column.
    
    - S(B) at t2: g 
    - S(B) at t3: g 
    - X(A) at t4: b 
    - X(C) at t5: g
    - X(C) at t6: b 
    - X(B) at t7: b 
    - X(B) at t8: b
    
2. [4 points] Give the wait-for graph for the lock requests in Table 3. List each edge in the graph like this: Tx → Ty because of Z (i.e., Tx is waiting for Ty to release its lock on resource Z). Order the edges in ascending order with respect to x.

    - T1 →T2 because of A 
    - T1 →T4 because of B 
    - T4 →T1 because of B 
    - T5 →T3 because of C

3. Determine whether there exists a deadlock in the lock requests in Table 3, and briefly explain why.

    Deadlock exists because there is a cycle (T1 → T4 → T1) in the depen- dency graph.

4. To prevent deadlock, we use the lock manager (LM ) that adopts the Wait-Die policy. We assume that in terms of priority: T1 > T2 > T3 > T4. Here, T1 > T2 because T1 is older than T2 (i.e., older transactions have higher priority). *Determine whether the lock request is granted (‘g’), blocked (‘b’), aborted (‘a’), or already dead(‘-’)*. Follow the same format as the previous question.

    - S(B) at t2: g
    - S(B) at t3: g
    - X(A) at t4: b
    - X(C) at t5: g
    - X(C) at t6: a (T5 dies because T3 holds the lock) T5的优先级低，拿不到互斥锁直接放弃
    - X(B) at t7: b
    - X(B) at t8: a (T4 dies because T1 is waiting for the lock)

    Wait-Die（“Old等待Young”）：如果T1具有更高的优先级，则T1等待T2。 否则T1中止

    高优先级想拿到低优先级的锁等待，而不是让低优先级的放弃

5. Now we use the lock manager (LM ) that adopts the Wound-Wait policy. We assume that in terms of priority: T1 > T2 > T3 > T4. Here, T1 > T2 because T1 is older than T2 (i.e., older transactions have higher priority). *Determine whether the lock request is granted (‘g’), blocked (‘b’), aborted (‘a’), or already dead(‘-’)*. Follow the same format as the previous question.

    - S(B) at t2: g
    - S(B) at t3: g
    - X(A) at t4: g (T1 wounds T2)
    - X(C) at t5: g
    - X(C) at t6: b
    - X(B) at t7: g (T1 wounds T4)
    - X(B) at t8: − (T4 is already dead from the wound by T1)

    wound-wait（“Young等待old”）：如果T1具有更高的优先级，则T2中止。 否则T1会等待。

## Question3: Hierarchical Locking

Consider a database (D) consisting of two tables, Cars (C) and Authors (A). Specifically,

- Cars(cid, aid, make, model, year, review), spans 500 pages, namely C1 to C500
- Authors(aid, first name, last name), spans 20 pages, namely A1 to A20

Further, each page contains 100 records, and we use the notation C3 : 20 to represent the 20th record on the third page of the Cars table. Similarly, A5 : 10 represents the 10th record on the fifth page of the Authors table.

We use Multiple-granularity locking, with S, X, IS, IX and SIX locks, and four levels of granularity: (1) *database-level (D)*, (2) *table-level (A, C)*, (3) *page-level (*A1−A20*,* C1−C500*)*, (4)*record-level(*A1 :1−A20 :100*,*C1 :1−C500 :100*)*.

For each of the following operations on the database, please determine the sequence of lock requests that should be generated by a transaction that wants to efficiently carry out these operations by maximizing concurrency.

Please follow the format of the examples listed below:

- write “IS(D)” for a request of database-level IS lock
- write “X(C2 : 30)” for a request of record-level X lock for the 30th record on the second page of the Cars table
- write “S(C2 : 30 − C3 : 100)” for a request of record-level S lock from the 30th record on the second page of the Cars table to the 100th record on the third page of the Cars table.

1. Fetch the 5th record on page A15.

   IS(D), IS(A), IS(A15), S(A15 : 5)

2. Scan all the records on pages C1 through C10, and modify the record C9 : 3.

   IX(D), SIX(C), IX(C9), X(C9 : 3);
    also acceptable: IX(D), IX(C), S(C1 − C8), S(C10), SIX(C9), X(C9 : 3)

3. Count the number of cars with ‘year’ > 1999.

   IS(D), S(C);

4. Increase the year of all cars by 1.

   IX(D), X(C)
    also acceptable: IX(D), IX(C), IX(C1 − C500), X(C1 : 1 − C500 : 100)

5. Capitalize the ‘first name’ of ALL authors and capitalize the make of ALL cars.

   X(D)

# 总结

先把这个homework4做完后，才好做lab3，加油。